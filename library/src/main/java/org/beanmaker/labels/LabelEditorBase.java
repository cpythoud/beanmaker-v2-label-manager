// Generated by BeanMaker V2, on January 20, 2025, 12:20:38â€¯PM EST
// Library Version #2.3-SNAPSHOT

package org.beanmaker.labels;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import java.util.List;

import org.beanmaker.v2.runtime.DBUtil;
import org.beanmaker.v2.runtime.DbBeanEditor;
import org.beanmaker.v2.runtime.DbBeanLocalization;
import org.beanmaker.v2.runtime.FieldValidationFunction;
import org.beanmaker.v2.runtime.FieldValidationResult;
import org.beanmaker.v2.runtime.FieldValidator;
import org.beanmaker.v2.runtime.GlobalValidator;
import org.beanmaker.v2.runtime.ToStringMaker;

import org.beanmaker.v2.runtime.annotations.DoNotEdit;

import org.beanmaker.v2.util.Strings;

import org.dbbeans.sql.DBQuerySetup;
import org.dbbeans.sql.DBTransaction;

import static org.beanmaker.labels.DbBeans.dbAccess;

@DoNotEdit(generator = "org.beanmaker.v2.codegen.BeanEditorBaseSourceFile", version = "2.3-SNAPSHOT", date = "2025-01-20T17:20:38.631959479Z")
abstract class LabelEditorBase extends DbBeanEditor {

	private String name = "";

	LabelEditorBase() {
		super(LabelParameters.INSTANCE);
	}

	LabelEditorBase(long id) {
		super(LabelParameters.INSTANCE);
		setId(id);
	}

	LabelEditorBase(long id, DBTransaction transaction) {
		super(LabelParameters.INSTANCE);
		setId(id, transaction);
	}

	LabelEditorBase(Label label) {
		super(LabelParameters.INSTANCE);
		init(label, false);
	}

	LabelEditorBase(long id, String name) {
		super(LabelParameters.INSTANCE);
		init(id, name);
	}

	LabelEditorBase(ResultSet rs) {
		super(LabelParameters.INSTANCE);
		init(DBUtil.getBeanID(rs, 1), DBUtil.getString(rs, 2));
	}

	static LabelEditor copyData(Label label) {
		LabelEditor labelEditor = new LabelEditor();
		labelEditor.init(label, true);
		return labelEditor;
	}

	void init(long id, String name) {
		this.id = id;
		this.name = name;
	}

	void init(Label label, boolean copy) {
		init(copy ? 0L : label.getId(), label.getName());
	}

	@Override
	public void setId(long id, DBTransaction transaction) {
		init(new Label(id, transaction), false);
	}

	public final Label toLabel() {
		return toLabel(null);
	}

	public Label toLabel(DBTransaction transaction) {
		if (id == 0)
			throw new IllegalStateException("Cannot create bean from uncommited data");

		return new Label(id, transaction);
	}

	@Override
	public String toString() {
		ToStringMaker stringMaker = new ToStringMaker(this);
		stringMaker.addField("name", name);
		return stringMaker.toString();
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public String getNameLabel() {
		return dbBeanLocalization.getLabel("name");
	}

	boolean isIdRequired() {
		return true;
	}

	boolean isNameRequired() {
		return true;
	}

	boolean isIdToBeUnique() {
		return true;
	}

	boolean isNameToBeUnique() {
		return true;
	}

	@Override
	protected boolean isDataOK(DBTransaction transaction) {
		dbBeanLocalization.clearErrorMessages();

		boolean ok = checkDataForName(transaction);

		if (ok)
			ok = checkGlobalData(transaction);

		return ok;
	}

	final boolean checkDataForName() {
		return checkDataForName(null);
	}

	boolean checkDataForName(DBTransaction transaction) {
		FieldValidator validator = FieldValidator.builder().dbBeanLocalization(dbBeanLocalization).id(id).fieldName("name").fieldLabel(getNameLabel()).empty(isNameEmpty()).required(isNameRequired()).shouldBeUnique(isNameToBeUnique()).isUnique(!isNameToBeUnique() || isNameUnique(transaction)).build();
		return validator.validate(getNameValidationFunctions(), transaction);
	}

	boolean checkGlobalData(DBTransaction transaction) {
		GlobalValidator validator = new GlobalValidator(dbBeanLocalization, id);
		return validator.validate(getDbBeanGlobalValidationFunctions(), transaction);
	}

	public boolean isNameEmpty() {
		return Strings.isEmpty(name);
	}

	List<FieldValidationFunction> getNameValidationFunctions() {
		return List.of(transaction -> {
			if (name.length() <= 128)
				return FieldValidationResult.OK;

			return FieldValidationResult.fatal("name" + DbBeanLocalization.TOO_LONG_EXT, 128, name.length());
		});
	}

	final boolean isNameUnique() {
		return isNameUnique(null);
	}

	boolean isNameUnique(DBTransaction transaction) {
		if (transaction == null)
			return DBUtil.checkUnicity(LabelParameters.INSTANCE, "name", name, id, dbAccess);

		return DBUtil.checkUnicity(LabelParameters.INSTANCE, "name", name, id, transaction);
	}

	@Override
	public void reset(DBTransaction transaction) {
		name = "";

		dbBeanLocalization.clearErrorMessages();
	}

	private class RecordCreationSetup implements DBQuerySetup {
		@Override
		public void setupPreparedStatement(PreparedStatement stat) throws SQLException {
			stat.setString(1, name);
		}
	}

	private class RecordUpdateSetup extends RecordCreationSetup {
		@Override
		public void setupPreparedStatement(PreparedStatement stat) throws SQLException {
			super.setupPreparedStatement(stat);
			stat.setLong(2, id);
		}
	}

	@Override
	protected long createRecord(DBTransaction transaction) {
		preCreateExtraDbActions(transaction);
		long id = transaction.addRecordCreation("INSERT INTO " + LabelParameters.INSTANCE.getDatabaseTableName() + " (`name`) VALUES (?)", new RecordCreationSetup());
		createExtraDbActions(transaction, id);
		return id;
	}

	@Override
	protected void updateRecord(DBTransaction transaction) {
		preUpdateExtraDbActions(transaction);
		transaction.addUpdate("UPDATE " + LabelParameters.INSTANCE.getDatabaseTableName() + " SET `name`=? WHERE id=?", new RecordUpdateSetup());
		updateExtraDbActions(transaction);
	}

	@Override
	protected DBTransaction createDBTransaction() {
		return DbBeans.createDBTransaction();
	}

}
